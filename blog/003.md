#### 《通过例子学Rust》 （浓缩版）
##### Hello world
1. 注释
   ```
   fn main() {
    // 这是行注释的例子

    /*
     * 这是另外一种注释——块注释。一般而言，行注释是推荐的注释格式，
     * 不过块注释在临时注释大块代码特别有用。/* 块注释可以 /* 嵌套, */ */
     * 所以只需很少按键就可注释掉这些 main() 函数中的行。/*/*/* 自己试试！*/*/*/
     */

    /*
    注意，上面的例子中纵向都有 `*`，这只是一种风格，实际上这并不是必须的。
    */

    // 观察块注释是如何简单地对表达式进行修改的，行注释则不能这样。
    // 删除注释分隔符将会改变结果。
    let x = 5 + /* 90 + */ 5;
    println!("Is `x` 10 or 100? x = {}", x);
   }
   ```
2. 格式化输出
   ```
   fn main() {
    // 变量内容会转化成字符串。
    println!("{} days", 31);

    // 不加后缀的话，31 就自动成为 i32 类型。
    // 你可以添加后缀来改变 31 的类型（例如使用 31i64 声明 31 为 i64 类型）。
    // 用变量替换字符串有多种写法。比如可以使用位置参数。
    println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");

    // 可以使用命名参数。
    println!("{subject} {verb} {object}",
             object="the lazy dog",
             subject="the quick brown fox",
             verb="jumps over");

    // 可以在 `:` 后面指定特殊的格式。
    println!("{} of {:b} people know binary, the other half don't", 1, 2);

    // 你可以按指定宽度来右对齐文本。
    // 下面语句输出 "     1"，5 个空格后面连着 1。
    println!("{number:>width$}", number=1, width=6);

    // 在数字左边补 0。下面语句输出 "000001"。
    println!("{number:>0width$}", number=1, width=6);

    // println! 会检查使用到的参数数量是否正确。
    println!("My name is {0}, {1} {0}", "Bond");
    // 改正 ^ 补上漏掉的参数："James"

    // 创建一个包含单个 `i32` 的结构体（structure）。命名为 `Structure`。
    #[allow(dead_code)]
    struct Structure(i32);

    // 但是像结构体这样的自定义类型需要更复杂的方式来处理。
    // 下面语句无法运行。
    println!("This struct `{}` won't print...", Structure(3));
    // 改正 ^ 注释掉此行。
    }
   ```
   ```
   #[derive(Debug)]
   struct Structure(i32);

   // 将 `Structure` 放到结构体 `Deep` 中。然后使 `Deep` 也能够打印。
   #[derive(Debug)]
   struct Deep(Structure);

   fn main() {
       // 使用 `{:?}` 打印和使用 `{}` 类似。
       println!("{:?} months in a year.", 12);
       println!("{1:?} {0:?} is the {actor:?} name.",
                "Slater",
                "Christian",
                actor="actor's");

       // `Structure` 也可以打印！
       println!("Now {:?} will print!", Structure(3));
       
       // 使用 `derive` 的一个问题是不能控制输出的形式。
       // 假如我只想展示一个 `7` 怎么办？
       println!("Now {:?} will print!", Deep(Structure(7)));

       // 使用{:#?}美化打印
       println!("{:#?}", Deep(Structure(7)));
   }
   ```
   ```
   use std::fmt;
   struct Structure(i32);
   // 为了使用 `{}` 标记，必须手动为类型实现 `fmt::Display` trait。
   impl fmt::Display for Structure {
       // 这个 trait 要求 `fmt` 使用与下面的函数完全一致的函数签名
       fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
           write!(f, "{}", self.0)
       }
   }

   //fmt::Display不适用于泛型容器
   //对于任何非泛型的容器类型， fmt::Display 都能够实现
   //实例
   struct List(Vec<i32>);

   impl fmt::Display for List {
       fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
           // 使用元组的下标获取值，并创建一个 `vec` 的引用。
           let vec = &self.0;
           write!(f, "[")?;
           // 使用 `v` 对 `vec` 进行迭代，并用 `count` 记录迭代次数。
           for (count, v) in vec.iter().enumerate() {
               // 对每个元素（第一个元素除外）加上逗号。
               // 使用 `?` 或 `try!` 来返回错误。
               if count != 0 { write!(f, ", ")?; }
               write!(f, "{}", v)?;
           }
           // 结尾中括号
           write!(f, "]")
       }
   }
   ```
##### 原生类型
1. 字面量、运算符
2. 元组
3. 数组、切片
##### 自定义类型
1. struct
2. enum
3. const
##### 变量绑定
1. 可变变量
2. 遮蔽
3. 先声明
4. 冻结
##### 类型系统
1. 类型转换
2. 字面量
3. 类型推断
4. 别名
##### 类型转换
1. From & Into
2. TryFrom & TryInto
3. ToString & Fromstr
##### 表达式
1. 表达式
##### 流程控制
1. if/else
2. loop
3. while
4. for
5. match
6. if let
7. while let
##### 函数
1. 方法
2. 闭包
3. 高阶函数
4. 发散函数
##### 模块
1. 可见性
2. 结构体的可见性
3. use
4. super & self
5. 文件分层
##### crate
1. 库
2. 使用库
##### cargo
1. 依赖
2. 约定规范
3. 测试
4. 构建脚本
##### 属性
1. dead_code
2. crate
3. cfg
##### 泛型
1. 函数
2. 实现
3. trait
4. 约束
5. 多重约束
6. where
7. newtype
8. 关联项
9. 虚类型参数
##### 作用域规则
1. RAII
2. 所有权与移动
3. 借用
4. 生命周期
##### trait
1. 派生
2. dyn
3. 运算符重载
4. Drop
5. Iterator
6. impl Trait
7. Clone
8. 父trait
9. 消除重叠trait
##### 宏
1. 语法
2. DRY（不写重复代码）
3. DSL（领域专用语言）
4. 可变参数接口
##### 错误处理
1. panic
2. Option & unwrap
3. Result
4. 处理多种Err类型
5. 遍历Result
##### std库
1. 箱子，栈，堆
2. vec
3. String
4. Option
5. Result
6. panic！
7. HashMap
8. Rc
9. Arc
##### std库更多
1. 线程
2. 通道
3. 路径
4. I/O
5. 子进程
6. 文件系统操作
7. 程序参数
8. 外部语言函数接口
##### 测试
1. 单元测试
2. 文档测试
3. 集成测试
4. 开发依赖
##### unsafe
1. unsafe
##### 兼容性
1. 原始标志符
##### 补充
1. 文档
2. Playpen